## RISC-V (RV32IMC) Assembly Functions

This directory contains RISC-V (concretely RV32IMC) Assembly implementations of nine low-level arithmetic functions used by X25519 key exchange and Ed25519 signatures. Seven of these nine functions perform arithmetic operations in the underlying 255-bit prime field $F_p$, which means they involve a reduction modulo $p = 2^{255} - 19$, while the remaining two are "conventional" Multi-Precision Integer (MPI) operations without modular reduction. The seven functions for arithmetic in $F_p$ are `gfp_add_rvm` (addition of two elements of $F_p$), `gfp_sub_rvm` (subtraction of two elements of $F_p$), `gfp_mul_rvm` (multiplication of two elements of $F_p$), `gfp_sqr_rvm` (squaring of an element of $F_p$), `gfp_mul32_rvm` (multiplication of an element of $F_p$ by a 32-bit integer), `gfp_cneg_rvm` (conditional negation of an element of $F_p$), and `gfp_hlv_rvm` (halving of an elements of $F_p$). On the other hand, the two functions for MPI arithmetic are `mpi_sub_rvm` (subtraction of two MPIs) and `mpi_shr_rvm` (1-bit right-shift of an MPI). The suffix `rvm` stands for _RISC-V with standard M extension_ and serves to distinguish the RISC-V assembly functions from those for other architectures and the conventional C functions. A detailed specification of the C functions can be found in [doc/api/gfparith.md](../../doc/api/gfparith.md) and [doc/api/mpiarith.md](../../doc/api/mpiarith.md), respectively.

### Improving performance and security

The reason why Micro25519 comes with hand-written Assembly code for nine low-level arithmetic functions is twofold. First, these functions have a significant impact on the execution time of X25519 key exchange and Ed25519 signature generation/verification. For example, `gfp_add`, `gfp_sub`, `gfp_mul`, `gfp_sqr`, and `gfp_mul32` are carried out in the main loop of variable-base scalar multiplication on Curve25519 (i.e., the Montgomery ladder). The former four, along with `gfp_cneg`, are also executed in the main loop of the fixed-base scalar multiplication on Ed25519 (i.e., the fixed-base comb method). Finally, `gfp_sub`, `gfp_hlv`, `mpi_sub`, and `mpi_shr` are performed by inversion in $F_p$ based on the Extended Euclidean Algorithm (EEA), which is a costly operation and contributes to the overall execution time of both fixed-base and variable-base scalar multiplication.

Apart from improving execution time, a second reason for implementing low-level arithmetic operations in Assembly is resistance to timing attacks. Each of the seven functions for arithmetic in $F_p$ is written so that it always executes exactly the same sequence of instructions, regardless of the actual value of the operands, to achieve constant execution time. In this way, the resistance against timing attacks does not depend on the compiler and the optimization settings used. The execution time of the two functions for MPI arithmetic depends only on the length of the operands (i.e., on the number of words), but not on their actual value.

### Evaluation on a Nuclei RV-Star board

The table below summarizes the execution time and (binary) code size of each of the nine Assembly functions and compares it with the that of the corresponding C functions. All execution times were measured on a [Nuclei RV-Star](https://doc.nucleisys.com/nuclei_sdk/design/board/gd32vf103v_rvstar.html) development board, which is equipped with a GigaDevive GD32VF103 "Bumblebee" microcontroller clocked at 108 MHz. The results for code size were determined for a RISC-V microcontroller that supports the standard C extension for compressed (i.e., 16-bit) instruction encodings, as is case for the GD32VF103. Overall, the Assembly library is relatively compact since the code size of all nine functiuons amounts to only 4.3 kB. Among the Assembly functions, the multiplication and squaring in $F_p$ are not only the largest in terms of code size, but also have the longest execution times, whereby `gfp_sqr` is about 24.5% faster than `gfp_mul`. The execition time of addition and subtraction in $F_p$ corresponds to, respectively, 14.7% and 18.4% of the multiplication time in $F_p$. 

| Arithmetic Function                  | ASM exec time | ASM code size | C99 exec time | C99 code size |
| :----------------------------------: | :------------:|:------------: | :-----------: | :-----------: |
| Addition in $F_p$ (`gfp_add`)        |    93 cycles  |  180 bytes    |  162 cycles   |  90 bytes     |
| Subtraction in $F_p$ (`gfp_add`)     |   116 cycles  |  234 bytes    |  184 cycles   | 140 bytes     |
| Multiplication in $F_p$ (`gfp_mul`)  |   632 cycles  | 1870 bytes    | 1400 cycles   | 284 bytes     |
| Squaring in $F_p$ (`gfp_sqr`)        |   477 cycles  | 1340 bytes    | 1023 cycles   | 386 bytes     |
| Mult. by 32-bit int. (`gfp_mul32`)   |   107 cycles  |  266 bytes    |  228 cycles   | 174 bytes     |
| Cond. negation in $F_p$ (`gfp_cneg`) |    86 cycles  |  192 bytes    |  153 cycles   | 124 bytes     |
| Halving in $F_p$ (`gfp_hlv`)         |   115 cycles  |  200 bytes    |  219 cycles   | 128 bytes     |
| MPI subtraction (`mpi_sub`)          |   132 cycles  |   48 bytes    |  140 cycles   |  58 bytes     |
| MPI 1-bit right-shift (`mpi_shr`)    |    95 cycles  |   42 bytes    |  103 cycles   |  68 bytes     |

The Assembly functions for field-arithmetic are roughly twice as fast as their C counterparts, but also larger in terms of code size, especially the multiplication and squaring. These relatively significant differences can be explained by the fact that the RISC-V Assembly code has been optimized primarily for high speed (e.g., all loops are fully unrolled), whereas the C functions aim for a trade-off between execution time and code size, which means they are implemented with "rolled" loops. On the other hand, the difference between Assembly and C is much smaller for the two MPI arithmetic functions. The Assembly implementations of these functions are generic in the sense that they support different operand lengths (determined by the parameter `len`), which makes them very similar to their C counterparts.

It is somewhat surprising that, currently (i.e., June 2025), there exists only one other Assembly-optimized X25519 implementation for 32-bit RISC-V (e.g., RV32) on GitHub, namely that of [Stefan van den Berg](https://github.com/stefanberg96/NaCl-RISC-V). He developed RV32 Assembly functions for multiplication in the prime field of Curve25519 as part of his [M.Sc. thesis](https://research.tue.nl/en/studentTheses/risc-v-implementation-of-the-nacl-library), which describes a RISC-V port of the [Network and Cryptography Library (NaCL)](https://nacl.cr.yp.to/). The RV32IM Assembly code for multiplication modulo $p = 2^{255} - 19$ can be found in [karatsuba226.S](https://github.com/stefanberg96/NaCl-RISC-V/blob/master/Programs/WithMultiplication/crypto_scalarmult/curve25519/Radix2.26/karatsuba226.S) and [karatsuba226_5.S](https://github.com/stefanberg96/NaCl-RISC-V/blob/master/Programs/WithMultiplication/crypto_scalarmult/curve25519/Radix2.26/karatsuba226_5.S). As indicated by the file names, this implementation is based on a radix-$2^{26}$ representation of the operands and uses [Karatsuba's algorithm](https://en.wikipedia.org/wiki/Karatsuba_algorithm) to speed up the multiplication. The function `karatsuba226_255` has an execution time of 1294 clock cycles when executed on the Nuclei RV-Star board, which is more than two times slower than `gfp_mul_rvm`.
